# Pattern Template: Impact Analysis
# Generalized from raw patterns for supplier failure impact assessment
name: impact_analysis
description: "Analyze downstream impact of entity failure (supplier, part, facility)"
version: "1.0"

derived_from:
  - patterns/raw/impact_analysis_001.yaml

handler: traverse  # Primary traversal
priority: 1
success_rate: 0.90

# When this pattern applies
applicability:
  query_signals:
    - "impact .* fail"
    - "affected .* if"
    - "what products"
    - "downstream impact"
    - "failure analysis"
    - "risk assessment"
    - "single point of failure"
    - "disruption"
    - "what depends on"
  relationship_properties:
    involves_chain: true
    traversal_complexity: YELLOW

# Multi-step analysis pattern
multi_step: true
steps:
  - name: identify_direct_impact
    description: "Find entities directly dependent on the failing entity"
    # Varies by starting entity type (see variants)

  - name: traverse_downstream
    description: "Traverse dependency graph to find all affected entities"
    handler: traverse

  - name: identify_end_impact
    description: "Find final impacted entities (products, orders, etc.)"
    # Final aggregation step

# Variants by starting entity type
variants:
  supplier_to_products:
    description: "What products are affected if a supplier fails?"
    example_queries:
      - "What products are affected if Acme Corp fails?"
      - "Impact of supplier X disruption"
      - "Products dependent on supplier Y"
    steps:
      - name: find_supplier_parts
        description: "Find parts supplied by this supplier"
        sql: |
          SELECT id FROM parts WHERE primary_supplier_id = {supplier_id}
          UNION
          SELECT part_id FROM part_suppliers WHERE supplier_id = {supplier_id}

      - name: traverse_bom_upstream
        description: "For each part, find all assemblies using it"
        handler: traverse
        handler_params:
          nodes_table: parts
          edges_table: bill_of_materials
          edge_from_col: child_part_id
          edge_to_col: parent_part_id
          direction: outbound
          max_depth: 10

      - name: find_affected_products
        description: "Find products containing affected assemblies"
        sql: |
          SELECT DISTINCT p.id, p.name, p.sku
          FROM products p
          JOIN product_components pc ON p.id = pc.product_id
          WHERE pc.part_id IN ({affected_part_ids})

  part_to_products:
    description: "What products are affected if a part is unavailable?"
    example_queries:
      - "Impact if part X is discontinued"
      - "Products using component Y"
    steps:
      - name: traverse_bom_upstream
        handler: traverse
        handler_params:
          nodes_table: parts
          edges_table: bill_of_materials
          edge_from_col: child_part_id
          edge_to_col: parent_part_id
          start_id: "{part_id}"
          direction: outbound
          max_depth: 10

      - name: find_affected_products
        sql: |
          SELECT DISTINCT p.* FROM products p
          JOIN product_components pc ON p.id = pc.product_id
          WHERE pc.part_id IN ({affected_part_ids})

  facility_to_orders:
    description: "What orders are affected if a facility fails?"
    example_queries:
      - "Orders affected by Chicago warehouse closure"
      - "Impact of facility X shutdown"
    steps:
      - name: find_affected_orders
        sql: |
          SELECT o.* FROM orders o
          WHERE o.shipping_facility_id = {facility_id}
          AND o.status IN ('pending', 'confirmed')

      - name: find_affected_routes
        handler: neighbors
        handler_params:
          nodes_table: facilities
          edges_table: transport_routes
          node_id: "{facility_id}"
          direction: both

# Ontology bindings for relationship chains
ontology_bindings:
  supplier_impact_chain:
    - relationship: provides
      direction: "supplier -> parts"
    - relationship: can_supply
      direction: "supplier -> parts (alternate)"
    - relationship: component_of
      direction: "parts -> assemblies (reverse)"
    - relationship: contains_component
      direction: "assemblies -> products (reverse)"

# Example instantiation
example:
  query: "What products are affected if Acme Corp fails?"
  steps:
    - description: "Find Acme Corp ID"
      sql: "SELECT id FROM suppliers WHERE name = 'Acme Corp'"
      result: 42

    - description: "Find parts from Acme Corp"
      sql: "SELECT id FROM parts WHERE primary_supplier_id = 42"
      result: [101, 102, 103]

    - description: "Traverse BOM for each part"
      handler: traverse
      handler_params:
        nodes_table: parts
        edges_table: bill_of_materials
        edge_from_col: child_part_id
        edge_to_col: parent_part_id
        start_id: 101  # Repeat for each part
        direction: outbound
        max_depth: 10

    - description: "Find affected products"
      sql: |
        SELECT DISTINCT p.name, p.sku
        FROM products p
        JOIN product_components pc ON p.id = pc.product_id
        WHERE pc.part_id IN (101, 102, 103, 201, 202, ...)  -- all affected parts
