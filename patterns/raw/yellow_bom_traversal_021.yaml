# YELLOW Pattern: component_of (Part → Part) BOM Traversal
# Discovered: Phase 2B - YELLOW Recursive Traversal
# Complexity: YELLOW
# Handler: traverse(), bom_explode()

name: bom_traversal_patterns
complexity: YELLOW
description: Recursive traversal patterns for Bill of Materials hierarchy

ontology_bindings:
  role: component_of
  domain: Part
  range: Part
  sql:
    table: bill_of_materials
    domain_key: child_part_id
    range_key: parent_part_id
    additional_columns:
      - quantity
      - unit
      - is_optional
      - assembly_sequence
  properties:
    acyclic: true

structure:
  total_edges: 14283
  max_depth: 5
  root_assemblies: 1261  # Have children but no parent
  leaf_parts: 1987      # Have parent but no children
  depth_distribution:
    level_0: 1274
    level_1: 5718
    level_2: 5299
    level_3: 24135
    level_4: 66719
    level_5: 2542

patterns:
  - name: bom_explosion
    description: "Explode BOM: Find all components of an assembly (parent → children)"
    applicability:
      keywords: [BOM, explosion, components, parts, assembly, contains, bill of materials]
      intent: "Find all components in an assembly recursively with quantities"
    direction: downstream
    parameters:
      - name: part_number
        type: string
        required: true
        example: "TURBO-ENC-001"
      - name: max_depth
        type: integer
        required: false
        default: 10
      - name: include_quantities
        type: boolean
        required: false
        default: true
    handler:
      name: bom_explode
      config:
        nodes_table: parts
        edges_table: bill_of_materials
        parent_col: parent_part_id
        child_col: child_part_id
        quantity_col: quantity
    sql_template: |
      WITH RECURSIVE bom_explode AS (
        SELECT bom.parent_part_id, bom.child_part_id,
               bom.quantity, bom.quantity as total_qty,
               1 as depth, ARRAY[bom.parent_part_id] as path
        FROM bill_of_materials bom
        JOIN parts p ON bom.parent_part_id = p.id
        WHERE p.part_number = {{part_number}}

        UNION ALL

        SELECT be.parent_part_id, bom.child_part_id,
               bom.quantity, be.total_qty * bom.quantity,
               be.depth + 1, be.path || bom.parent_part_id
        FROM bill_of_materials bom
        JOIN bom_explode be ON bom.parent_part_id = be.child_part_id
        WHERE be.depth < {{max_depth}}
        AND NOT bom.parent_part_id = ANY(be.path)
      )
      SELECT p.part_number, p.description, p.category,
             be.depth, be.quantity as direct_qty, be.total_qty
      FROM bom_explode be
      JOIN parts p ON be.child_part_id = p.id
      ORDER BY be.depth, p.part_number
    execution:
      time_ms: 14.7
      handler_verified: true
      safety_note: "Full depth hits 21K nodes > 10K limit; use depth=2 for 23 components"
      result: "TURBO-ENC-001 depth=2: 23 components with quantities"

  - name: where_used
    description: "Where-Used: Find all assemblies using a part (child → parents)"
    applicability:
      keywords: [where used, assemblies, parent, used in, impact, dependency]
      intent: "Find all assemblies that use this part directly or indirectly"
    direction: upstream
    parameters:
      - name: part_number
        type: string
        required: true
      - name: max_depth
        type: integer
        required: false
        default: 10
    handler:
      name: traverse
      config:
        nodes_table: parts
        edges_table: bill_of_materials
        edge_from_col: child_part_id
        edge_to_col: parent_part_id
        direction: upstream
    sql_template: |
      WITH RECURSIVE where_used AS (
        SELECT bom.child_part_id, bom.parent_part_id,
               1 as depth, ARRAY[bom.child_part_id] as path
        FROM bill_of_materials bom
        JOIN parts p ON bom.child_part_id = p.id
        WHERE p.part_number = {{part_number}}

        UNION ALL

        SELECT wu.child_part_id, bom.parent_part_id,
               wu.depth + 1, wu.path || bom.child_part_id
        FROM bill_of_materials bom
        JOIN where_used wu ON bom.child_part_id = wu.parent_part_id
        WHERE wu.depth < {{max_depth}}
        AND NOT bom.child_part_id = ANY(wu.path)
      )
      SELECT DISTINCT p.part_number, p.description, p.category, MIN(wu.depth) as min_depth
      FROM where_used wu
      JOIN parts p ON wu.parent_part_id = p.id
      GROUP BY p.id, p.part_number, p.description, p.category
      ORDER BY min_depth, p.part_number
    execution:
      time_ms: 1.7
      result: "PRT-000466: used in 144 parent assemblies"

  - name: bom_impact_analysis
    description: "Which root assemblies are affected if a part fails?"
    applicability:
      keywords: [impact, failure, root, assembly, affected, risk, shortage]
      intent: "Find root assemblies impacted by part shortage or failure"
    direction: upstream
    parameters:
      - name: part_number
        type: string
        required: true
    handler:
      name: traverse_collecting
      config:
        target_condition: "is_root_assembly"
    sql_template: |
      WITH RECURSIVE where_used AS (
        SELECT bom.child_part_id as start_id, bom.parent_part_id,
               1 as depth, ARRAY[bom.child_part_id] as path
        FROM bill_of_materials bom
        JOIN parts p ON bom.child_part_id = p.id
        WHERE p.part_number = {{part_number}}

        UNION ALL

        SELECT wu.start_id, bom.parent_part_id,
               wu.depth + 1, wu.path || bom.child_part_id
        FROM bill_of_materials bom
        JOIN where_used wu ON bom.child_part_id = wu.parent_part_id
        WHERE wu.depth < 10
        AND NOT bom.child_part_id = ANY(wu.path)
      )
      SELECT p.part_number, p.description, MIN(wu.depth) as hops
      FROM where_used wu
      JOIN parts p ON wu.parent_part_id = p.id
      WHERE NOT EXISTS (
        SELECT 1 FROM bill_of_materials b2 WHERE b2.child_part_id = wu.parent_part_id
      )
      GROUP BY p.id, p.part_number, p.description
      ORDER BY hops, p.part_number
    execution:
      time_ms: 1.0
      result: "PRT-000466 failure affects 95 root assemblies"

  - name: bom_depth_limited
    description: "BOM explosion limited to specific depth"
    applicability:
      keywords: [BOM, depth, level, limited, first level, direct]
      intent: "Get BOM components up to a specific depth level"
    direction: downstream
    parameters:
      - name: part_number
        type: string
        required: true
      - name: depth
        type: integer
        required: true
        default: 1
    sql_template: |
      WITH RECURSIVE bom_explode AS (
        SELECT bom.parent_part_id, bom.child_part_id, bom.quantity,
               1 as depth
        FROM bill_of_materials bom
        JOIN parts p ON bom.parent_part_id = p.id
        WHERE p.part_number = {{part_number}}

        UNION ALL

        SELECT be.parent_part_id, bom.child_part_id, bom.quantity,
               be.depth + 1
        FROM bill_of_materials bom
        JOIN bom_explode be ON bom.parent_part_id = be.child_part_id
        WHERE be.depth < {{depth}}
      )
      SELECT p.part_number, p.description, p.category, be.depth, be.quantity
      FROM bom_explode be
      JOIN parts p ON be.child_part_id = p.id
      ORDER BY be.depth, p.part_number
    execution:
      time_ms: 2.0

  - name: bom_cost_rollup
    description: "Calculate total cost of an assembly from BOM"
    applicability:
      keywords: [BOM, cost, rollup, total, price, material cost]
      intent: "Calculate total material cost of an assembly"
    direction: downstream
    parameters:
      - name: part_number
        type: string
        required: true
    sql_template: |
      WITH RECURSIVE bom_explode AS (
        SELECT bom.child_part_id, bom.quantity as total_qty
        FROM bill_of_materials bom
        JOIN parts p ON bom.parent_part_id = p.id
        WHERE p.part_number = {{part_number}}

        UNION ALL

        SELECT bom.child_part_id, be.total_qty * bom.quantity
        FROM bill_of_materials bom
        JOIN bom_explode be ON bom.parent_part_id = be.child_part_id
      )
      SELECT p.part_number,
             ROUND(SUM(be.total_qty * p.unit_cost)::numeric, 2) as total_cost,
             SUM(be.total_qty) as total_parts
      FROM bom_explode be
      JOIN parts p ON be.child_part_id = p.id
      GROUP BY ROLLUP(p.part_number)
      ORDER BY total_cost DESC NULLS FIRST
      LIMIT 20
    execution:
      time_ms: 5.0

  - name: common_components
    description: "Find common components between two assemblies"
    applicability:
      keywords: [common, components, shared, both, compare, assemblies]
      intent: "Find parts used in both assemblies"
    parameters:
      - name: part_number_1
        type: string
        required: true
      - name: part_number_2
        type: string
        required: true
    sql_template: |
      WITH RECURSIVE bom1 AS (
        SELECT bom.child_part_id
        FROM bill_of_materials bom
        JOIN parts p ON bom.parent_part_id = p.id
        WHERE p.part_number = {{part_number_1}}
        UNION
        SELECT bom.child_part_id
        FROM bill_of_materials bom
        JOIN bom1 b ON bom.parent_part_id = b.child_part_id
      ),
      bom2 AS (
        SELECT bom.child_part_id
        FROM bill_of_materials bom
        JOIN parts p ON bom.parent_part_id = p.id
        WHERE p.part_number = {{part_number_2}}
        UNION
        SELECT bom.child_part_id
        FROM bill_of_materials bom
        JOIN bom2 b ON bom.parent_part_id = b.child_part_id
      )
      SELECT p.part_number, p.description, p.category
      FROM bom1
      JOIN bom2 ON bom1.child_part_id = bom2.child_part_id
      JOIN parts p ON bom1.child_part_id = p.id
      ORDER BY p.part_number
    execution:
      time_ms: 10.0

  - name: critical_path_bom
    description: "Find critical parts in BOM (is_critical = true)"
    applicability:
      keywords: [critical, parts, BOM, important, essential, risk]
      intent: "Find critical parts within an assembly's BOM"
    direction: downstream
    parameters:
      - name: part_number
        type: string
        required: true
    handler:
      name: traverse_collecting
      config:
        target_condition: "is_critical = true"
    sql_template: |
      WITH RECURSIVE bom_explode AS (
        SELECT bom.child_part_id, bom.quantity as total_qty, 1 as depth
        FROM bill_of_materials bom
        JOIN parts p ON bom.parent_part_id = p.id
        WHERE p.part_number = {{part_number}}

        UNION ALL

        SELECT bom.child_part_id, be.total_qty * bom.quantity, be.depth + 1
        FROM bill_of_materials bom
        JOIN bom_explode be ON bom.parent_part_id = be.child_part_id
        WHERE be.depth < 10
      )
      SELECT p.part_number, p.description, p.category,
             MIN(be.depth) as depth, SUM(be.total_qty) as total_qty
      FROM bom_explode be
      JOIN parts p ON be.child_part_id = p.id
      WHERE p.is_critical = true
      GROUP BY p.id, p.part_number, p.description, p.category
      ORDER BY depth, total_qty DESC
    execution:
      time_ms: 5.0
