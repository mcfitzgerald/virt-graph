# ============================================================================
# Prism Consumer Goods (PCG) - FMCG Supply Chain Ontology
# ============================================================================
#
# Spec: magical-launching-forest.md Phase 3
#
# Entity Classes (TBox): 67 tables across SCOR-DS domains
# Relationship Classes (RBox): ~50 relationships with operation type mappings
#
# Validation:
#   Layer 1: poetry run linkml-lint --validate-only fmcg_example/ontology/prism_fmcg.yaml
#   Layer 2: OntologyAccessor("fmcg_example/ontology/prism_fmcg.yaml", validate=True)
#
# Modeling Patterns (from spec Section 3):
#   3.1 Dual Modeling (Rich Link): CarrierContract, Promotion as Node + Edge
#   3.2 Deep Hierarchy (Flattened Edges): v_location_divisions shortcut
#   3.3 Equivalency (Substitutes): SKU -> SKU direct + cluster pattern
#   3.4 Composite Keys: order_lines, shipment_lines, formula_ingredients
#   3.5 UoM Normalization: v_transport_normalized SQL view
#   3.6 Hyper-edges (Event Reification): Shipment node + v_batch_destinations shortcut
#   3.7 Temporal Bounds: carrier_contracts, promotions with effective dates

id: https://virt-graph.dev/schemas/prism_fmcg
name: prism_fmcg
version: "0.9.21"
description: >-
  FMCG supply chain domain ontology for Virtual Graph.
  Models Prism Consumer Goods - a Colgate-Palmolive-inspired surrogate
  demonstrating "Formula-to-Shelf" pipeline with high-velocity, massive-volume
  patterns across global divisions.

  Key Differentiator vs supply_chain_example:
    - Horizontal fan-out (1 Batch -> 50,000 retail nodes) vs deep BOM recursion
    - Full SCOR-DS coverage: Plan/Source/Transform/Order/Fulfill/Return/Orchestrate
    - Desmet Triangle integration: Service, Cost, Cash on every edge

prefixes:
  linkml: https://w3id.org/linkml/
  vg: https://virt-graph.dev/

imports:
  - linkml:types

default_range: string

annotations:
  vg:database_type: postgresql
  vg:database_version: "15"
  vg:connection_string: "postgresql://virt_graph:dev_password@localhost:5433/prism_fmcg"

# =============================================================================
# CLASSES (TBox) - 67 Entity Classes by SCOR-DS Domain
# =============================================================================

classes:

  # ===========================================================================
  # DOMAIN A: SOURCE (Procurement & Inbound) - 8 tables
  # ===========================================================================

  Ingredient:
    description: >-
      Raw chemicals with CAS numbers, purity requirements, and storage conditions.
      Named entities: ING-PALM-001 (single-source Palm Oil), ING-SORB-001 (Sorbitol,
      goes into ALL toothpaste), ING-PEPP-001 (Peppermint Oil, seasonal).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: ingredients
      vg:primary_key: id
      vg:identifier: ingredient_code
      vg:row_count: 200
      vg:context: >-
        {
          "definition": "Raw material input to manufacturing formulas",
          "business_logic": "Ingredients tracked by CAS number for regulatory compliance",
          "llm_prompt_hint": "For recall trace, start here and traverse to batches via formula_ingredients",
          "examples": ["Find all SKUs using Palm Oil", "Which ingredients are single-sourced?"]
        }
    attributes:
      id:
        range: integer
        required: true
      ingredient_code:
        range: string
      name:
        range: string
      cas_number:
        range: string
      category:
        range: string
      is_active:
        range: boolean

  Supplier:
    description: >-
      Global supplier network organized by tier (1/2/3). Tier 1 = direct strategic,
      Tier 2 = qualified alternates, Tier 3 = spot market.
      Named entity: SUP-PALM-MY-001 (single-source Palm Oil from Malaysia).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: suppliers
      vg:primary_key: id
      vg:identifier: supplier_code
      vg:soft_delete_column: null
      vg:row_count: 150
      vg:context: >-
        {
          "definition": "External party providing ingredients to PCG plants",
          "business_logic": "qualification_status must be 'qualified' for active sourcing",
          "llm_prompt_hint": "For SPOF analysis, find suppliers where COUNT(ingredients) = 1",
          "examples": ["Find single-source suppliers", "Which suppliers have expired certifications?"]
        }
    attributes:
      id:
        range: integer
        required: true
      supplier_code:
        range: string
      name:
        range: string
      tier:
        range: integer
      country:
        range: string
      region:
        range: string
      qualification_status:
        range: string
      is_active:
        range: boolean

  SupplierIngredient:
    description: >-
      Junction table linking suppliers to ingredients they can supply.
      Contains lead times, MOQs, costs, and delivery performance metrics.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: supplier_ingredients
      vg:primary_key: id
      vg:row_count: 500
      vg:context: >-
        {
          "definition": "Approved supplier-ingredient sourcing relationship",
          "business_logic": "is_preferred indicates primary source; is_approved required for orders",
          "llm_prompt_hint": "Use for cost comparisons and lead time analysis between suppliers"
        }
    attributes:
      id:
        range: integer
        required: true
      supplier_id:
        range: integer
      ingredient_id:
        range: integer
      unit_cost:
        range: float
      lead_time_days:
        range: integer
      is_preferred:
        range: boolean
      is_approved:
        range: boolean

  Certification:
    description: >-
      Supplier certifications: ISO9001, ISO14001, GMP, Halal, Kosher, RSPO, FSC.
      Used for compliance checks and ESG scoring.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: certifications
      vg:primary_key: id
      vg:row_count: 400
    attributes:
      id:
        range: integer
        required: true
      supplier_id:
        range: integer
      certification_type:
        range: string
      expiry_date:
        range: date
      is_valid:
        range: boolean

  PurchaseOrder:
    description: >-
      Purchase orders to suppliers for ingredient procurement.
      Links SOURCE to TRANSFORM via plant_id.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: purchase_orders
      vg:primary_key: id
      vg:identifier: po_number
      vg:row_count: 5000
    attributes:
      id:
        range: integer
        required: true
      po_number:
        range: string
      supplier_id:
        range: integer
      plant_id:
        range: integer
      status:
        range: string

  PurchaseOrderLine:
    description: >-
      Line items on purchase orders specifying ingredient, quantity, and price.
      Composite primary key: (po_id, line_number).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: purchase_order_lines
      vg:primary_key: '["po_id", "line_number"]'
      vg:row_count: 15000
    attributes:
      po_id:
        range: integer
        required: true
      line_number:
        range: integer
        required: true
      ingredient_id:
        range: integer
      quantity:
        range: float
      unit_price:
        range: float

  GoodsReceipt:
    description: >-
      Receipt of goods from suppliers, closing the SOURCE procurement loop.
      Links to PO and captures actual received quantities.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: goods_receipts
      vg:primary_key: id
      vg:identifier: gr_number
      vg:row_count: 4500
    attributes:
      id:
        range: integer
        required: true
      gr_number:
        range: string
      po_id:
        range: integer
      plant_id:
        range: integer
      status:
        range: string

  GoodsReceiptLine:
    description: >-
      Line-level receipt detail with lot numbers for traceability.
      Critical for recall trace - links supplier lot to internal batch.
      Composite PK: (gr_id, line_number).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: goods_receipt_lines
      vg:primary_key: '["gr_id", "line_number"]'
      vg:row_count: 14000
      vg:context: >-
        {
          "definition": "Received ingredient lot with quality status",
          "business_logic": "lot_number links to batch_ingredients for recall tracing",
          "llm_prompt_hint": "For upstream recall trace, join to batch_ingredients via lot_number"
        }
    attributes:
      gr_id:
        range: integer
        required: true
      line_number:
        range: integer
        required: true
      ingredient_id:
        range: integer
      lot_number:
        range: string
      quality_status:
        range: string

  # ===========================================================================
  # DOMAIN B: TRANSFORM (Manufacturing) - 9 tables
  # ===========================================================================

  Plant:
    description: >-
      7 manufacturing facilities globally across 5 divisions.
      Plants have production lines and produce batches.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: plants
      vg:primary_key: id
      vg:identifier: plant_code
      vg:row_count: 7
    attributes:
      id:
        range: integer
        required: true
      plant_code:
        range: string
      name:
        range: string
      division_id:
        range: integer
      country:
        range: string
      capacity_tons_per_day:
        range: float

  ProductionLine:
    description: >-
      Manufacturing lines within plants with specific capabilities.
      Line types: mixing, filling, packaging, labeling.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: production_lines
      vg:primary_key: id
      vg:identifier: line_code
      vg:row_count: 35
    attributes:
      id:
        range: integer
        required: true
      line_code:
        range: string
      plant_id:
        range: integer
      line_type:
        range: string
      product_family:
        range: string
      capacity_units_per_hour:
        range: integer

  Formula:
    description: >-
      Recipe/BOM definitions for products. Specifies ingredients and their quantities.
      FMCG formulas are shallow (5-15 ingredients) vs aerospace deep BOMs.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: formulas
      vg:primary_key: id
      vg:identifier: formula_code
      vg:row_count: 100
      vg:context: >-
        {
          "definition": "Manufacturing recipe specifying ingredient composition",
          "business_logic": "Formulas versioned; only status='approved' can be produced",
          "llm_prompt_hint": "For ingredient impact, traverse formula_ingredients to find affected products"
        }
    attributes:
      id:
        range: integer
        required: true
      formula_code:
        range: string
      product_id:
        range: integer
      batch_size_kg:
        range: float
      status:
        range: string

  FormulaIngredient:
    description: >-
      Composition detail: which ingredients in which quantities per formula.
      Composite PK: (formula_id, ingredient_id, sequence).
      BOM explosion lite - typically 5-15 ingredients per formula.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: formula_ingredients
      vg:primary_key: '["formula_id", "ingredient_id", "sequence"]'
      vg:row_count: 800
      vg:context: >-
        {
          "definition": "Ingredient requirement in formula with sequence and quantity",
          "business_logic": "sequence determines processing order; quantity_percent for proportions",
          "llm_prompt_hint": "Use hierarchical_aggregation for quantity explosion (like BOM)"
        }
    attributes:
      formula_id:
        range: integer
        required: true
      ingredient_id:
        range: integer
        required: true
      sequence:
        range: integer
        required: true
      quantity_kg:
        range: float
      quantity_percent:
        range: float

  WorkOrder:
    description: >-
      Scheduled production linking PLAN to TRANSFORM.
      Created from supply_plans, produces batches.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: work_orders
      vg:primary_key: id
      vg:identifier: wo_number
      vg:row_count: 10000
    attributes:
      id:
        range: integer
        required: true
      wo_number:
        range: string
      formula_id:
        range: integer
      plant_id:
        range: integer
      production_line_id:
        range: integer
      planned_quantity_kg:
        range: float
      status:
        range: string

  WorkOrderMaterial:
    description: >-
      Planned material consumption per work order.
      Composite PK: (wo_id, line_number).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: work_order_materials
      vg:primary_key: '["wo_id", "line_number"]'
      vg:row_count: 80000
    attributes:
      wo_id:
        range: integer
        required: true
      line_number:
        range: integer
        required: true
      ingredient_id:
        range: integer
      planned_quantity_kg:
        range: float
      lot_number:
        range: string

  Batch:
    description: >-
      Production lot - the key traceability node.
      Named entity: B-2024-RECALL-001 for recall testing.
      One batch -> many SKUs -> many shipments -> many retail locations.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: batches
      vg:primary_key: id
      vg:identifier: batch_number
      vg:row_count: 50000
      vg:context: >-
        {
          "definition": "Production lot with QC status and expiry tracking",
          "business_logic": "is_contaminated=true triggers recall; qc_status must be 'approved' to ship",
          "llm_prompt_hint": "Key node for recall trace - use recursive_traversal to find affected stores",
          "examples": ["Trace contaminated batch to all stores", "Find batches expiring in 15 days"]
        }
    attributes:
      id:
        range: integer
        required: true
      batch_number:
        range: string
      wo_id:
        range: integer
      formula_id:
        range: integer
      plant_id:
        range: integer
      production_date:
        range: date
      expiry_date:
        range: date
      qc_status:
        range: string
      is_contaminated:
        range: boolean

  BatchIngredient:
    description: >-
      Actual ingredient consumption per batch for mass balance.
      lot_number links back to goods_receipt_lines for upstream tracing.
      Composite PK: (batch_id, ingredient_id, sequence).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: batch_ingredients
      vg:primary_key: '["batch_id", "ingredient_id", "sequence"]'
      vg:row_count: 400000
      vg:context: >-
        {
          "definition": "Actual material consumption with lot traceability",
          "llm_prompt_hint": "For upstream recall, trace lot_number back to goods_receipt_lines"
        }
    attributes:
      batch_id:
        range: integer
        required: true
      ingredient_id:
        range: integer
        required: true
      sequence:
        range: integer
        required: true
      actual_quantity_kg:
        range: float
      lot_number:
        range: string

  BatchCostLedger:
    description: >-
      Cost breakdown per batch: material, labor, energy, overhead.
      Used for landed cost calculations.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: batch_cost_ledger
      vg:primary_key: id
      vg:row_count: 250000
      vg:context: >-
        {
          "definition": "Production cost components for margin analysis",
          "llm_prompt_hint": "Aggregate by cost_type for cost breakdown; sum for total batch cost"
        }
    attributes:
      id:
        range: integer
        required: true
      batch_id:
        range: integer
      cost_type:
        range: string
      cost_amount:
        range: float

  # ===========================================================================
  # DOMAIN C: PRODUCT (SKU Master) - 5 tables
  # ===========================================================================

  Product:
    description: >-
      Product families: PrismWhite (oral care), ClearWave (home care), AquaPure (personal care).
      Products explode into ~2,000 SKUs via packaging variants and regions.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: products
      vg:primary_key: id
      vg:identifier: product_code
      vg:row_count: 30
    attributes:
      id:
        range: integer
        required: true
      product_code:
        range: string
      name:
        range: string
      brand:
        range: string
      category:
        range: string
      is_active:
        range: boolean

  PackagingType:
    description: >-
      Container specifications: tubes, bottles, pouches with size variants.
      Drives SKU explosion (6oz tube, 8oz tube, 1L bottle, etc.).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: packaging_types
      vg:primary_key: id
      vg:identifier: packaging_code
      vg:row_count: 50
    attributes:
      id:
        range: integer
        required: true
      packaging_code:
        range: string
      container_type:
        range: string
      size_value:
        range: float
      size_unit:
        range: string
      units_per_case:
        range: integer

  SKU:
    description: >-
      Stock Keeping Unit - the explosion point (~2,000 SKUs).
      Combines product + packaging + region + language.
      Key hub for order_lines and shipment_lines.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: skus
      vg:primary_key: id
      vg:identifier: sku_code
      vg:row_count: 2000
      vg:context: >-
        {
          "definition": "Sellable unit combining product, packaging, and regional attributes",
          "business_logic": "region and language determine market availability",
          "llm_prompt_hint": "High fan-out node - connects to orders, shipments, inventory",
          "examples": ["Top 20 SKUs by volume", "Find SKUs available in APAC region"]
        }
    attributes:
      id:
        range: integer
        required: true
      sku_code:
        range: string
      name:
        range: string
      product_id:
        range: integer
      packaging_id:
        range: integer
      formula_id:
        range: integer
      region:
        range: string
      list_price:
        range: float
      is_active:
        range: boolean

  SKUCost:
    description: >-
      Standard costs by type (material, labor, overhead, packaging, freight, landed).
      Time-effective for cost rollups.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: sku_costs
      vg:primary_key: id
      vg:row_count: 12000
      vg:context: >-
        {
          "definition": "Standard cost component with effectivity dates",
          "llm_prompt_hint": "Sum by cost_type for total; use effective dates for valid costs"
        }
    attributes:
      id:
        range: integer
        required: true
      sku_id:
        range: integer
      cost_type:
        range: string
      cost_amount:
        range: float
      effective_from:
        range: date
      effective_to:
        range: date

  SKUSubstitute:
    description: >-
      Substitute/equivalent SKU relationships (symmetric).
      Types: size_variant, regional_variant, promotional, emergency.
      Pattern 3.3: Direct edge + cluster node for equivalency.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: sku_substitutes
      vg:primary_key: id
      vg:row_count: 3000
      vg:context: >-
        {
          "definition": "Interchangeable SKU relationship for allocation and fulfillment",
          "business_logic": "is_bidirectional=true means symmetric relationship",
          "llm_prompt_hint": "Use connected_components to find substitution clusters"
        }
    attributes:
      id:
        range: integer
        required: true
      sku_id:
        range: integer
      substitute_sku_id:
        range: integer
      substitute_type:
        range: string
      priority:
        range: integer
      is_bidirectional:
        range: boolean

  # ===========================================================================
  # DOMAIN D: ORDER (Demand Signal) - 7 tables
  # ===========================================================================

  Channel:
    description: >-
      4 channel types: B&M Large (40%), B&M Distributor (30%), E-commerce (20%), DTC (10%).
      Determines fulfillment patterns and margin profiles.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: channels
      vg:primary_key: id
      vg:identifier: channel_code
      vg:row_count: 4
    attributes:
      id:
        range: integer
        required: true
      channel_code:
        range: string
      channel_type:
        range: string
      volume_percent:
        range: float
      margin_percent:
        range: float

  Promotion:
    description: >-
      Trade promotions with lift multipliers and hangover effects.
      Named entity: PROMO-BF-2024 (Black Friday, 3x demand + 30% hangover).
      Pattern 3.1: Dual modeling - Node (trade spend) + Edge (demand lift).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: promotions
      vg:primary_key: id
      vg:identifier: promo_code
      vg:row_count: 200
      vg:context: >-
        {
          "definition": "Trade promotion event with demand impact parameters",
          "business_logic": "lift_multiplier during promo; hangover_multiplier after end_date",
          "llm_prompt_hint": "Use temporal_traversal with date bounds for active promos",
          "examples": ["Find Black Friday promotions", "Calculate bullwhip impact from promos"]
        }
    attributes:
      id:
        range: integer
        required: true
      promo_code:
        range: string
      name:
        range: string
      promo_type:
        range: string
      start_date:
        range: date
      end_date:
        range: date
      lift_multiplier:
        range: float
      hangover_multiplier:
        range: float
      status:
        range: string

  PromotionSKU:
    description: >-
      Junction linking promotions to participating SKUs.
      Composite PK: (promo_id, sku_id).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: promotion_skus
      vg:primary_key: '["promo_id", "sku_id"]'
      vg:row_count: 2000
    attributes:
      promo_id:
        range: integer
        required: true
      sku_id:
        range: integer
        required: true
      specific_lift_multiplier:
        range: float

  PromotionAccount:
    description: >-
      Junction linking promotions to retail accounts running them.
      Composite PK: (promo_id, retail_account_id).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: promotion_accounts
      vg:primary_key: '["promo_id", "retail_account_id"]'
      vg:row_count: 1500
    attributes:
      promo_id:
        range: integer
        required: true
      retail_account_id:
        range: integer
        required: true
      trade_spend_allocation:
        range: float

  Order:
    description: >-
      Customer orders (~240K). Links retail accounts/locations to demand.
      Order types: standard, rush, backorder, promotional.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: orders
      vg:primary_key: id
      vg:identifier: order_number
      vg:row_count: 240000
      vg:context: >-
        {
          "definition": "Customer demand signal with delivery requirements",
          "business_logic": "status flow: pending -> confirmed -> allocated -> shipped -> delivered",
          "llm_prompt_hint": "For OTIF analysis, compare actual_delivery_date to requested_delivery_date"
        }
    attributes:
      id:
        range: integer
        required: true
      order_number:
        range: string
      retail_account_id:
        range: integer
      retail_location_id:
        range: integer
      channel_id:
        range: integer
      order_date:
        range: date
      requested_delivery_date:
        range: date
      actual_delivery_date:
        range: date
      status:
        range: string
      promo_id:
        range: integer
      total_amount:
        range: float

  OrderLine:
    description: >-
      Order line items with SKU, quantity, price.
      Composite PK: (order_id, line_number).
      High-volume table linking demand to SKUs.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: order_lines
      vg:primary_key: '["order_id", "line_number"]'
      vg:row_count: 4700000
    attributes:
      order_id:
        range: integer
        required: true
      line_number:
        range: integer
        required: true
      sku_id:
        range: integer
      quantity_cases:
        range: integer
      unit_price:
        range: float
      status:
        range: string

  OrderAllocation:
    description: >-
      ATP/allocation linking inventory batches to order lines.
      Connects ORDER to FULFILL domain.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: order_allocations
      vg:primary_key: id
      vg:row_count: 550000
    attributes:
      id:
        range: integer
        required: true
      order_id:
        range: integer
      order_line_number:
        range: integer
      dc_id:
        range: integer
      batch_id:
        range: integer
      allocated_cases:
        range: integer
      status:
        range: string

  # ===========================================================================
  # DOMAIN E: FULFILL (Outbound) - 11 tables
  # ===========================================================================

  Division:
    description: >-
      5 global divisions: NAM (Knoxville), LATAM (Sao Paulo), APAC (Singapore),
      EUR (Paris), AFR-EUR (Dubai). Top of hierarchy for aggregation.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: divisions
      vg:primary_key: id
      vg:identifier: division_code
      vg:row_count: 5
    attributes:
      id:
        range: integer
        required: true
      division_code:
        range: string
      name:
        range: string
      headquarters_city:
        range: string
      is_active:
        range: boolean

  DistributionCenter:
    description: >-
      ~25 DCs globally. Types: regional, national, cross_dock, ecommerce.
      Named entity: DC-NAM-CHI-001 (Chicago bottleneck DC).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: distribution_centers
      vg:primary_key: id
      vg:identifier: dc_code
      vg:row_count: 25
      vg:context: >-
        {
          "definition": "Warehouse fulfilling orders to retail locations",
          "business_logic": "capacity_cases determines throughput limits",
          "llm_prompt_hint": "Use centrality() to find critical/bottleneck DCs",
          "examples": ["Find DCs at >90% capacity", "Which DC serves most stores?"]
        }
    attributes:
      id:
        range: integer
        required: true
      dc_code:
        range: string
      name:
        range: string
      division_id:
        range: integer
      dc_type:
        range: string
      country:
        range: string
      capacity_cases:
        range: integer
      is_active:
        range: boolean

  Port:
    description: >-
      Ocean/air freight nodes for multi-leg international routing.
      Types: ocean, air, rail, multimodal.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: ports
      vg:primary_key: id
      vg:identifier: port_code
      vg:row_count: 30
    attributes:
      id:
        range: integer
        required: true
      port_code:
        range: string
      name:
        range: string
      port_type:
        range: string
      country:
        range: string

  RetailAccount:
    description: >-
      Archetype-based accounts (~100). Types: megamart, valueclub, urbanessential,
      regional_grocer, indie_retail, digital_first, omni_retailer, prism_direct.
      Named entity: ACCT-MEGA-001 (MegaMart, 4,500 stores, 25% of orders).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: retail_accounts
      vg:primary_key: id
      vg:identifier: account_code
      vg:row_count: 100
      vg:context: >-
        {
          "definition": "Customer account representing retail chain",
          "business_logic": "is_strategic=true for key accounts with special treatment",
          "llm_prompt_hint": "Hot node for Pareto analysis - top 20% = 80% volume"
        }
    attributes:
      id:
        range: integer
        required: true
      account_code:
        range: string
      name:
        range: string
      account_type:
        range: string
      channel_id:
        range: integer
      division_id:
        range: integer
      store_count:
        range: integer
      is_strategic:
        range: boolean
      is_active:
        range: boolean

  RetailLocation:
    description: >-
      Individual stores (~10,000). Format: hypermarket, supermarket, convenience, pharmacy.
      Pattern 3.2: Deep hierarchy with flattened edges via v_location_divisions.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: retail_locations
      vg:primary_key: id
      vg:identifier: location_code
      vg:row_count: 10000
      vg:context: >-
        {
          "definition": "Physical store where products are sold to consumers",
          "business_logic": "primary_dc_id determines default fulfillment source",
          "llm_prompt_hint": "Use v_location_divisions for fast division-level aggregation"
        }
    attributes:
      id:
        range: integer
        required: true
      location_code:
        range: string
      name:
        range: string
      retail_account_id:
        range: integer
      store_format:
        range: string
      country:
        range: string
      primary_dc_id:
        range: integer
      is_active:
        range: boolean

  Shipment:
    description: >-
      Physical movements (~180K). Types: plant_to_dc, dc_to_dc, dc_to_store, direct_to_store.
      Pattern 3.6: Hyper-edge reification - modeled as node + shortcut edges.
      Polymorphic origin/destination via type columns.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: shipments
      vg:primary_key: id
      vg:identifier: shipment_number
      vg:row_count: 180000
      vg:context: >-
        {
          "definition": "Physical movement of goods between locations",
          "business_logic": "Polymorphic origin/destination - use origin_type/destination_type",
          "llm_prompt_hint": "Use as node for full detail; use v_batch_destinations for fast recall trace"
        }
    attributes:
      id:
        range: integer
        required: true
      shipment_number:
        range: string
      shipment_type:
        range: string
      origin_type:
        range: string
      origin_id:
        range: integer
      destination_type:
        range: string
      destination_id:
        range: integer
      carrier_id:
        range: integer
      route_id:
        range: integer
      ship_date:
        range: date
      status:
        range: string
      freight_cost:
        range: float

  ShipmentLine:
    description: >-
      Shipment line items with batch/lot tracking (~540K).
      Critical for recall trace - links batches to destinations.
      Composite PK: (shipment_id, line_number).
      batch_fraction supports batch splitting (Section 4.5.1).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: shipment_lines
      vg:primary_key: '["shipment_id", "line_number"]'
      vg:row_count: 540000
      vg:context: >-
        {
          "definition": "Line item with batch/lot for traceability",
          "business_logic": "batch_fraction for split batches; sum must not exceed 1.0",
          "llm_prompt_hint": "Key traversal edge for batch -> store recall trace"
        }
    attributes:
      shipment_id:
        range: integer
        required: true
      line_number:
        range: integer
        required: true
      sku_id:
        range: integer
      batch_id:
        range: integer
      quantity_cases:
        range: integer
      batch_fraction:
        range: float
      lot_number:
        range: string

  Inventory:
    description: >-
      Stock by location with aging buckets.
      Polymorphic location (plant, dc, store, in_transit).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: inventory
      vg:primary_key: id
      vg:row_count: 500000
      vg:context: >-
        {
          "definition": "Current stock position by location, SKU, and batch",
          "business_logic": "quantity_available = quantity_cases - quantity_reserved",
          "llm_prompt_hint": "For inventory turns, compare to order_lines volume"
        }
    attributes:
      id:
        range: integer
        required: true
      location_type:
        range: string
      location_id:
        range: integer
      sku_id:
        range: integer
      batch_id:
        range: integer
      quantity_cases:
        range: integer
      quantity_reserved:
        range: integer
      expiry_date:
        range: date
      aging_bucket:
        range: string

  PickWave:
    description: >-
      Picking/packing execution grouping orders for DC processing.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: pick_waves
      vg:primary_key: id
      vg:identifier: wave_number
      vg:row_count: 15000
    attributes:
      id:
        range: integer
        required: true
      wave_number:
        range: string
      dc_id:
        range: integer
      wave_date:
        range: date
      status:
        range: string

  PickWaveOrder:
    description: >-
      Junction linking pick waves to orders.
      Composite PK: (wave_id, order_id).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: pick_wave_orders
      vg:primary_key: '["wave_id", "order_id"]'
      vg:row_count: 180000
    attributes:
      wave_id:
        range: integer
        required: true
      order_id:
        range: integer
        required: true
      pick_sequence:
        range: integer
      status:
        range: string

  # ===========================================================================
  # DOMAIN E2: LOGISTICS (Transport Network) - 7 tables
  # ===========================================================================

  Carrier:
    description: >-
      Carrier profiles with sustainability ratings.
      Types: trucking, rail, ocean, air, parcel, ltl, 3pl.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: carriers
      vg:primary_key: id
      vg:identifier: carrier_code
      vg:row_count: 50
    attributes:
      id:
        range: integer
        required: true
      carrier_code:
        range: string
      name:
        range: string
      carrier_type:
        range: string
      sustainability_rating:
        range: string
      is_preferred:
        range: boolean
      is_active:
        range: boolean

  CarrierContract:
    description: >-
      Rate agreements with date effectivity.
      Pattern 3.1: Dual modeling - Node (contract lifecycle) + Edge (rate lookups).
      Pattern 3.7: Temporal bounds for valid_at filtering.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: carrier_contracts
      vg:primary_key: id
      vg:identifier: contract_number
      vg:row_count: 150
      vg:context: >-
        {
          "definition": "Contractual rate agreement with carrier",
          "business_logic": "Only active contracts with current date in [effective_from, effective_to]",
          "llm_prompt_hint": "Use temporal_traversal with valid_at for rate lookups"
        }
    attributes:
      id:
        range: integer
        required: true
      contract_number:
        range: string
      carrier_id:
        range: integer
      contract_type:
        range: string
      effective_from:
        range: date
      effective_to:
        range: date
      status:
        range: string

  CarrierRate:
    description: >-
      Rate tables by mode, weight break, lane. Used for freight cost calculations.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: carrier_rates
      vg:primary_key: id
      vg:row_count: 2000
      vg:context: >-
        {
          "llm_prompt_hint": "Use for landed cost path_aggregate with rate_per_kg or rate_per_case"
        }
    attributes:
      id:
        range: integer
        required: true
      contract_id:
        range: integer
      origin_type:
        range: string
      origin_code:
        range: string
      destination_type:
        range: string
      destination_code:
        range: string
      transport_mode:
        range: string
      rate_per_kg:
        range: float
      rate_per_case:
        range: float
      transit_days:
        range: integer

  RouteSegment:
    description: >-
      Atomic transport legs: origin -> destination.
      Named entity: LANE-SH-LA-001 (seasonal Shanghai->LA, 50% capacity winter).
      Pattern 3.7: Temporal flickering via is_seasonal and seasonal_months.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: route_segments
      vg:primary_key: id
      vg:identifier: segment_code
      vg:row_count: 300
      vg:context: >-
        {
          "definition": "Atomic transport leg between two nodes",
          "business_logic": "is_seasonal with seasonal_months for winter storm capacity reduction",
          "llm_prompt_hint": "Use shortest_path with distance_km or transit_time_hours as weight"
        }
    attributes:
      id:
        range: integer
        required: true
      segment_code:
        range: string
      origin_type:
        range: string
      origin_id:
        range: integer
      destination_type:
        range: string
      destination_id:
        range: integer
      transport_mode:
        range: string
      distance_km:
        range: float
      transit_time_hours:
        range: float
      is_seasonal:
        range: boolean
      is_active:
        range: boolean

  Route:
    description: >-
      Composed routes from multiple segments (Plant -> Port -> Ocean -> DC).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: routes
      vg:primary_key: id
      vg:identifier: route_code
      vg:row_count: 500
    attributes:
      id:
        range: integer
        required: true
      route_code:
        range: string
      name:
        range: string
      total_distance_km:
        range: float
      total_transit_hours:
        range: float
      is_preferred:
        range: boolean
      is_active:
        range: boolean

  RouteSegmentAssignment:
    description: >-
      Links routes to segments in sequence order.
      Composite PK: (route_id, segment_id, sequence).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: route_segment_assignments
      vg:primary_key: '["route_id", "segment_id", "sequence"]'
      vg:row_count: 1500
    attributes:
      route_id:
        range: integer
        required: true
      segment_id:
        range: integer
        required: true
      sequence:
        range: integer
        required: true

  ShipmentLeg:
    description: >-
      Actual execution tracking which segments used per shipment.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: shipment_legs
      vg:primary_key: id
      vg:row_count: 400000
    attributes:
      id:
        range: integer
        required: true
      shipment_id:
        range: integer
      segment_id:
        range: integer
      leg_sequence:
        range: integer
      carrier_id:
        range: integer
      freight_cost:
        range: float
      status:
        range: string

  # ===========================================================================
  # DOMAIN E3: ESG/SUSTAINABILITY - 5 tables
  # ===========================================================================

  EmissionFactor:
    description: >-
      CO2 emission factors by transport mode and fuel type.
      Used to calculate Scope 3 Category 4 & 9 emissions.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: emission_factors
      vg:primary_key: id
      vg:row_count: 100
    attributes:
      id:
        range: integer
        required: true
      transport_mode:
        range: string
      fuel_type:
        range: string
      carrier_id:
        range: integer
      co2_kg_per_km:
        range: float
      co2_kg_per_ton_km:
        range: float

  ShipmentEmission:
    description: >-
      Calculated CO2 per shipment/leg for Scope 3 reporting.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: shipment_emissions
      vg:primary_key: id
      vg:row_count: 400000
      vg:context: >-
        {
          "definition": "Calculated carbon emissions per shipment",
          "llm_prompt_hint": "Use path_aggregate to sum CO2 across multi-leg routes"
        }
    attributes:
      id:
        range: integer
        required: true
      shipment_id:
        range: integer
      shipment_leg_id:
        range: integer
      scope:
        range: string
      co2_kg:
        range: float

  SupplierESGScore:
    description: >-
      Supplier sustainability assessments: EcoVadis, CDP, ISO14001, SBTi.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: supplier_esg_scores
      vg:primary_key: id
      vg:row_count: 300
      vg:context: >-
        {
          "definition": "Sustainability assessment scores for supplier",
          "llm_prompt_hint": "sbti_committed=false identifies carbon risk suppliers"
        }
    attributes:
      id:
        range: integer
        required: true
      supplier_id:
        range: integer
      assessment_date:
        range: date
      ecovadis_score:
        range: integer
      sbti_committed:
        range: boolean
      sbti_validated:
        range: boolean

  SustainabilityTarget:
    description: >-
      Division/account-level carbon reduction targets with tracking.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: sustainability_targets
      vg:primary_key: id
      vg:row_count: 50
    attributes:
      id:
        range: integer
        required: true
      target_type:
        range: string
      target_entity_id:
        range: integer
      metric:
        range: string
      target_value:
        range: float
      current_value:
        range: float
      status:
        range: string

  ModalShiftOpportunity:
    description: >-
      Identified truck->rail/intermodal opportunities for carbon reduction.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: modal_shift_opportunities
      vg:primary_key: id
      vg:row_count: 100
    attributes:
      id:
        range: integer
        required: true
      route_segment_id:
        range: integer
      current_mode:
        range: string
      proposed_mode:
        range: string
      co2_reduction_tons:
        range: float
      cost_impact_usd:
        range: float
      status:
        range: string

  # ===========================================================================
  # DOMAIN F: PLAN (Demand & Supply Planning) - 9 tables
  # ===========================================================================

  POSSale:
    description: >-
      Point-of-sale signals - actual demand at store/SKU level.
      Feeds demand forecasting and replenishment.
      In this simulation, each row represents WEEKLY AGGREGATED sales 
      per SKU per Store to reflect high-velocity hypermarket throughput.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: pos_sales
      vg:primary_key: id
      vg:row_count: 600000
      vg:context: >-
        {
          "definition": "Weekly aggregated consumer purchase transactions for a specific SKU at a specific retail location",
          "business_logic": "quantity_eaches represents total sales for the week (Hypermarket Velocity ~60/week)",
          "llm_prompt_hint": "Aggregate by sale_week for weekly demand patterns; note that each row is already a store-week aggregate"
        }
    attributes:
      id:
        range: integer
        required: true
      retail_location_id:
        range: integer
      sku_id:
        range: integer
      sale_date:
        range: date
      quantity_eaches:
        range: integer
      is_promotional:
        range: boolean
      promo_id:
        range: integer

  DemandForecast:
    description: >-
      Statistical/ML forecasts by SKU/location. Types: statistical, ml_based, manual, consensus.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: demand_forecasts
      vg:primary_key: id
      vg:row_count: 500000
      vg:context: >-
        {
          "definition": "Predicted demand for planning horizon",
          "business_logic": "forecast_type='consensus' is the official planning number",
          "llm_prompt_hint": "Use path_aggregate for demand propagation from stores to plants"
        }
    attributes:
      id:
        range: integer
        required: true
      forecast_version:
        range: string
      sku_id:
        range: integer
      location_type:
        range: string
      location_id:
        range: integer
      forecast_date:
        range: date
      forecast_quantity_cases:
        range: float
      forecast_type:
        range: string

  ForecastAccuracy:
    description: >-
      MAPE, bias tracking for forecast quality monitoring.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: forecast_accuracy
      vg:primary_key: id
      vg:row_count: 500000
    attributes:
      id:
        range: integer
        required: true
      forecast_id:
        range: integer
      sku_id:
        range: integer
      mape:
        range: float
      bias_percent:
        range: float

  ConsensusAdjustment:
    description: >-
      S&OP overrides to statistical forecast with business justification.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: consensus_adjustments
      vg:primary_key: id
      vg:row_count: 20000
    attributes:
      id:
        range: integer
        required: true
      forecast_id:
        range: integer
      adjustment_type:
        range: string
      adjustment_percent:
        range: float
      reason:
        range: string

  ReplenishmentParam:
    description: >-
      Safety stock, reorder points, review cycles by SKU/location.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: replenishment_params
      vg:primary_key: id
      vg:row_count: 100000
    attributes:
      id:
        range: integer
        required: true
      sku_id:
        range: integer
      location_type:
        range: string
      location_id:
        range: integer
      safety_stock_days:
        range: float
      reorder_point_cases:
        range: integer
      lead_time_days:
        range: integer

  DemandAllocation:
    description: >-
      How forecasted demand is allocated down the network (division -> DC -> store).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: demand_allocation
      vg:primary_key: id
      vg:row_count: 1000000
    attributes:
      id:
        range: integer
        required: true
      forecast_id:
        range: integer
      from_location_type:
        range: string
      from_location_id:
        range: integer
      to_location_type:
        range: string
      to_location_id:
        range: integer
      sku_id:
        range: integer
      allocated_quantity_cases:
        range: float

  CapacityPlan:
    description: >-
      Available capacity by plant/line/period for supply planning.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: capacity_plans
      vg:primary_key: id
      vg:row_count: 5000
    attributes:
      id:
        range: integer
        required: true
      plan_version:
        range: string
      plant_id:
        range: integer
      production_line_id:
        range: integer
      period_start:
        range: date
      available_hours:
        range: float
      planned_hours:
        range: float

  SupplyPlan:
    description: >-
      Planned production/procurement to meet demand.
      Links PLAN to TRANSFORM (via work orders) and SOURCE (via POs).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: supply_plans
      vg:primary_key: id
      vg:row_count: 50000
    attributes:
      id:
        range: integer
        required: true
      plan_version:
        range: string
      sku_id:
        range: integer
      source_type:
        range: string
      source_id:
        range: integer
      destination_type:
        range: string
      destination_id:
        range: integer
      planned_quantity_cases:
        range: integer
      status:
        range: string

  PlanException:
    description: >-
      Gap identification when demand > capacity or other planning issues.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: plan_exceptions
      vg:primary_key: id
      vg:row_count: 5000
    attributes:
      id:
        range: integer
        required: true
      plan_version:
        range: string
      exception_type:
        range: string
      severity:
        range: string
      sku_id:
        range: integer
      gap_quantity_cases:
        range: integer
      status:
        range: string

  # ===========================================================================
  # DOMAIN G: RETURN (Regenerate) - 4 tables
  # ===========================================================================

  RMAAuthorization:
    description: >-
      Return Merchandise Authorization workflow.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: rma_authorizations
      vg:primary_key: id
      vg:identifier: rma_number
      vg:row_count: 5000
    attributes:
      id:
        range: integer
        required: true
      rma_number:
        range: string
      retail_account_id:
        range: integer
      reason_code:
        range: string
      status:
        range: string

  Return:
    description: >-
      Return events - physical movement of goods back from stores.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: returns
      vg:primary_key: id
      vg:identifier: return_number
      vg:row_count: 10000
    attributes:
      id:
        range: integer
        required: true
      return_number:
        range: string
      rma_id:
        range: integer
      order_id:
        range: integer
      retail_location_id:
        range: integer
      dc_id:
        range: integer
      status:
        range: string

  ReturnLine:
    description: >-
      Return line items with condition assessment.
      Composite PK: (return_id, line_number).
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: return_lines
      vg:primary_key: '["return_id", "line_number"]'
      vg:row_count: 30000
    attributes:
      return_id:
        range: integer
        required: true
      line_number:
        range: integer
        required: true
      sku_id:
        range: integer
      batch_id:
        range: integer
      quantity_cases:
        range: integer
      condition:
        range: string

  DispositionLog:
    description: >-
      Disposition decisions: restock, scrap, donate, rework, liquidate, quarantine.
      Links RETURN to TRANSFORM for regeneration.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: disposition_logs
      vg:primary_key: id
      vg:row_count: 30000
    attributes:
      id:
        range: integer
        required: true
      return_id:
        range: integer
      return_line_number:
        range: integer
      disposition:
        range: string
      quantity_cases:
        range: integer

  # ===========================================================================
  # DOMAIN H: ORCHESTRATE (Hub) - 6 tables
  # ===========================================================================

  KPIThreshold:
    description: >-
      Desmet Triangle targets: Service (OTIF, OSA), Cost (landed cost, freight),
      Cash (inventory turns, DSO). Industry benchmarks included.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: kpi_thresholds
      vg:primary_key: id
      vg:identifier: kpi_code
      vg:row_count: 50
      vg:context: >-
        {
          "definition": "Target threshold for key performance indicator",
          "business_logic": "desmet_dimension links to Desmet Triangle (service, cost, cash)",
          "llm_prompt_hint": "Compare kpi_actuals.actual_value to threshold for RAG status"
        }
    attributes:
      id:
        range: integer
        required: true
      kpi_code:
        range: string
      kpi_name:
        range: string
      kpi_category:
        range: string
      desmet_dimension:
        range: string
      target_value:
        range: float
      warning_threshold:
        range: float
      critical_threshold:
        range: float

  KPIActual:
    description: >-
      Calculated KPI values vs thresholds with trend tracking.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: kpi_actuals
      vg:primary_key: id
      vg:row_count: 100000
    attributes:
      id:
        range: integer
        required: true
      kpi_id:
        range: integer
      measurement_date:
        range: date
      scope_type:
        range: string
      scope_id:
        range: integer
      actual_value:
        range: float
      status:
        range: string
      trend:
        range: string

  OSAMetric:
    description: >-
      On-shelf availability measurements (~500K). Critical service KPI for FMCG.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: osa_metrics
      vg:primary_key: id
      vg:row_count: 500000
      vg:context: >-
        {
          "definition": "On-shelf availability measurement at store/SKU",
          "business_logic": "is_in_stock=false with out_of_stock_reason for root cause",
          "llm_prompt_hint": "Aggregate by out_of_stock_reason to find systemic issues",
          "examples": ["Find stores with <90% OSA", "Correlate OSA with DC bottlenecks"]
        }
    attributes:
      id:
        range: integer
        required: true
      retail_location_id:
        range: integer
      sku_id:
        range: integer
      measurement_date:
        range: date
      is_in_stock:
        range: boolean
      out_of_stock_reason:
        range: string

  BusinessRule:
    description: >-
      Policy management: allocation rules, pricing rules, fulfillment rules.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: business_rules
      vg:primary_key: id
      vg:identifier: rule_code
      vg:row_count: 100
    attributes:
      id:
        range: integer
        required: true
      rule_code:
        range: string
      rule_name:
        range: string
      rule_category:
        range: string
      rule_type:
        range: string
      is_active:
        range: boolean

  RiskEvent:
    description: >-
      Risk registry: supplier_disruption, quality_hold, logistics_delay, demand_shock.
      Polymorphic affected_entity for cross-domain impact.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: risk_events
      vg:primary_key: id
      vg:identifier: event_code
      vg:row_count: 500
      vg:context: >-
        {
          "definition": "Identified risk with probability and impact assessment",
          "llm_prompt_hint": "Use resilience_analysis to model impact of risk events"
        }
    attributes:
      id:
        range: integer
        required: true
      event_code:
        range: string
      event_type:
        range: string
      severity:
        range: string
      affected_entity_type:
        range: string
      affected_entity_id:
        range: integer
      risk_score:
        range: float
      status:
        range: string

  AuditLog:
    description: >-
      Change tracking for governance and compliance.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: audit_log
      vg:primary_key: id
      vg:row_count: 1000000
    attributes:
      id:
        range: integer
        required: true
      table_name:
        range: string
      record_id:
        range: integer
      action:
        range: string
      changed_at:
        range: datetime

  # ===========================================================================
  # VIEW-BACKED CLASSES (for shortcut edges and aggregation)
  # ===========================================================================

  LocationDivisionView:
    description: >-
      Flattened hierarchy view: Location -> Account -> Division (Pattern 3.2).
      Enables fast division-level aggregation without 2-hop traversal.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: v_location_divisions
      vg:primary_key: location_id
      vg:row_count: 10000
    attributes:
      location_id:
        range: integer
        required: true
      account_id:
        range: integer
      division_id:
        range: integer

  BatchDestinationView:
    description: >-
      Shortcut edge for recall tracing (Pattern 3.6).
      Batch -> RetailLocation bypassing Shipment node for speed.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: v_batch_destinations
      vg:primary_key: batch_id
      vg:row_count: 500000
      vg:context: >-
        {
          "definition": "Pre-joined batch-to-destination for fast recall trace",
          "llm_prompt_hint": "Use for recall trace when carrier details not needed"
        }
    attributes:
      batch_id:
        range: integer
        required: true
      destination_type:
        range: string
      destination_id:
        range: integer
      ship_date:
        range: date

  TransportNormalizedView:
    description: >-
      UoM-normalized route segments (Pattern 3.5).
      All distances in km, costs in USD.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: v_transport_normalized
      vg:primary_key: id
      vg:row_count: 300
    attributes:
      id:
        range: integer
        required: true
      origin_type:
        range: string
      origin_id:
        range: integer
      destination_type:
        range: string
      destination_id:
        range: integer
      distance_km:
        range: float
      transit_time_hours:
        range: float

  SingleSourceIngredientView:
    description: >-
      SPOF detection view: ingredients with exactly 1 approved supplier.
    instantiates:
      - vg:SQLMappedClass
    annotations:
      vg:table: v_single_source_ingredients
      vg:primary_key: ingredient_id
      vg:row_count: 50
      vg:context: >-
        {
          "definition": "Ingredients with single-source supplier risk",
          "llm_prompt_hint": "Direct query for SPOF detection without handler"
        }
    attributes:
      ingredient_id:
        range: integer
        required: true
      ingredient_code:
        range: string
      sole_supplier_code:
        range: string

# =============================================================================
# SLOTS (RBox) - Relationships with Operation Type Mappings
# =============================================================================

slots:

  # ===========================================================================
  # SOURCE Domain Relationships
  # ===========================================================================

  supplies_ingredient:
    description: >-
      Supplier -> Ingredient relationship via supplier_ingredients junction.
      Includes cost, lead time, and performance metrics.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: supplier_ingredients
      vg:domain_key: supplier_id
      vg:range_key: ingredient_id
      vg:domain_class: Supplier
      vg:range_class: Ingredient
      vg:operation_types: '["direct_join", "recursive_traversal"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "unit_cost", "type": "decimal", "unit": "USD"}, {"name": "lead_time_days", "type": "integer", "unit": "days"}]'
      vg:edge_attributes: '[{"name": "is_preferred", "type": "boolean"}, {"name": "is_approved", "type": "boolean"}]'
      vg:sql_filter: "is_approved = true"
      vg:context: >-
        {
          "definition": "Approved sourcing relationship between supplier and ingredient",
          "llm_prompt_hint": "Filter is_preferred=true for primary source",
          "traversal_semantics": {"inbound": "which suppliers can source this ingredient", "outbound": "which ingredients does this supplier provide"}
        }
    range: Ingredient

  has_certification:
    description: >-
      Supplier -> Certification for compliance checking.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: certifications
      vg:domain_key: supplier_id
      vg:range_key: id
      vg:domain_class: Supplier
      vg:range_class: Certification
      vg:operation_types: '["direct_join"]'
      vg:sql_filter: "is_valid = true"
    range: Certification

  po_from_supplier:
    description: >-
      PurchaseOrder -> Supplier relationship.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: purchase_orders
      vg:domain_key: id
      vg:range_key: supplier_id
      vg:domain_class: PurchaseOrder
      vg:range_class: Supplier
      vg:operation_types: '["direct_join"]'
    range: Supplier

  po_line_ingredient:
    description: >-
      PurchaseOrderLine -> Ingredient with quantity and price.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: purchase_order_lines
      vg:domain_key: '["po_id", "line_number"]'
      vg:range_key: ingredient_id
      vg:domain_class: PurchaseOrderLine
      vg:range_class: Ingredient
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "quantity", "type": "decimal", "unit": "kg"}, {"name": "unit_price", "type": "decimal", "unit": "USD"}]'
    range: Ingredient

  gr_line_lot:
    description: >-
      GoodsReceiptLine contains lot_number linking to batch_ingredients.
      Critical for upstream recall tracing.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: goods_receipt_lines
      vg:domain_key: '["gr_id", "line_number"]'
      vg:range_key: ingredient_id
      vg:domain_class: GoodsReceiptLine
      vg:range_class: Ingredient
      vg:operation_types: '["direct_join", "recursive_traversal"]'
      vg:edge_attributes: '[{"name": "lot_number", "type": "string"}, {"name": "quality_status", "type": "string"}]'
    range: Ingredient

  # ===========================================================================
  # TRANSFORM Domain Relationships
  # ===========================================================================

  plant_in_division:
    description: >-
      Plant -> Division for organizational hierarchy.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: plants
      vg:domain_key: id
      vg:range_key: division_id
      vg:domain_class: Plant
      vg:range_class: Division
      vg:operation_types: '["direct_join"]'
    range: Division

  line_at_plant:
    description: >-
      ProductionLine -> Plant relationship.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: production_lines
      vg:domain_key: id
      vg:range_key: plant_id
      vg:domain_class: ProductionLine
      vg:range_class: Plant
      vg:operation_types: '["direct_join"]'
    range: Plant

  formula_contains_ingredient:
    description: >-
      Formula -> Ingredient via formula_ingredients with quantities.
      BOM-lite: typically 5-15 ingredients per formula.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: formula_ingredients
      vg:domain_key: formula_id
      vg:range_key: ingredient_id
      vg:domain_class: Formula
      vg:range_class: Ingredient
      vg:operation_types: '["direct_join", "hierarchical_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "quantity_kg", "type": "decimal", "unit": "kg"}, {"name": "quantity_percent", "type": "decimal", "unit": "percent"}]'
      vg:edge_attributes: '[{"name": "sequence", "type": "integer"}]'
      vg:context: >-
        {
          "definition": "Ingredient requirement in formula (BOM-lite)",
          "llm_prompt_hint": "Use hierarchical_aggregation for quantity explosion"
        }
    range: Ingredient

  formula_for_product:
    description: >-
      Formula -> Product relationship.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: formulas
      vg:domain_key: id
      vg:range_key: product_id
      vg:domain_class: Formula
      vg:range_class: Product
      vg:operation_types: '["direct_join"]'
    range: Product

  wo_executes_formula:
    description: >-
      WorkOrder -> Formula for production scheduling.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: work_orders
      vg:domain_key: id
      vg:range_key: formula_id
      vg:domain_class: WorkOrder
      vg:range_class: Formula
      vg:operation_types: '["direct_join", "recursive_traversal"]'
    range: Formula

  batch_from_wo:
    description: >-
      Batch -> WorkOrder linking production output to schedule.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: batches
      vg:domain_key: id
      vg:range_key: wo_id
      vg:domain_class: Batch
      vg:range_class: WorkOrder
      vg:operation_types: '["direct_join"]'
    range: WorkOrder

  batch_uses_formula:
    description: >-
      Batch -> Formula for recipe traceability.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: batches
      vg:domain_key: id
      vg:range_key: formula_id
      vg:domain_class: Batch
      vg:range_class: Formula
      vg:operation_types: '["direct_join", "recursive_traversal"]'
    range: Formula

  batch_ingredient_consumption:
    description: >-
      Batch -> Ingredient via batch_ingredients with actual consumption.
      lot_number links to goods_receipt_lines for upstream tracing.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: batch_ingredients
      vg:domain_key: batch_id
      vg:range_key: ingredient_id
      vg:domain_class: Batch
      vg:range_class: Ingredient
      vg:operation_types: '["direct_join", "recursive_traversal", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "actual_quantity_kg", "type": "decimal", "unit": "kg"}]'
      vg:edge_attributes: '[{"name": "lot_number", "type": "string"}]'
      vg:context: >-
        {
          "definition": "Actual material consumption with lot traceability",
          "llm_prompt_hint": "Join lot_number to goods_receipt_lines for upstream recall"
        }
    range: Ingredient

  batch_cost:
    description: >-
      Batch -> BatchCostLedger for cost breakdown.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: batch_cost_ledger
      vg:domain_key: batch_id
      vg:range_key: id
      vg:domain_class: Batch
      vg:range_class: BatchCostLedger
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "cost_amount", "type": "decimal", "unit": "USD"}]'
    range: BatchCostLedger

  # ===========================================================================
  # PRODUCT Domain Relationships
  # ===========================================================================

  sku_of_product:
    description: >-
      SKU -> Product for product hierarchy.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: skus
      vg:domain_key: id
      vg:range_key: product_id
      vg:domain_class: SKU
      vg:range_class: Product
      vg:operation_types: '["direct_join"]'
    range: Product

  sku_packaging:
    description: >-
      SKU -> PackagingType for packaging specification.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: skus
      vg:domain_key: id
      vg:range_key: packaging_id
      vg:domain_class: SKU
      vg:range_class: PackagingType
      vg:operation_types: '["direct_join"]'
    range: PackagingType

  sku_formula:
    description: >-
      SKU -> Formula for manufacturing recipe.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: skus
      vg:domain_key: id
      vg:range_key: formula_id
      vg:domain_class: SKU
      vg:range_class: Formula
      vg:operation_types: '["direct_join", "recursive_traversal"]'
    range: Formula

  sku_substitutes_for:
    description: >-
      SKU -> SKU substitution relationship (symmetric).
      Pattern 3.3: Direct edge for simple lookups.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: sku_substitutes
      vg:domain_key: sku_id
      vg:range_key: substitute_sku_id
      vg:domain_class: SKU
      vg:range_class: SKU
      vg:operation_types: '["direct_join", "connected_components"]'
      vg:symmetric: true
      vg:edge_attributes: '[{"name": "substitute_type", "type": "string"}, {"name": "priority", "type": "integer"}]'
      vg:context: >-
        {
          "definition": "Interchangeable SKU for fulfillment",
          "llm_prompt_hint": "Use connected_components to find substitution clusters"
        }
    range: SKU

  # ===========================================================================
  # ORDER Domain Relationships
  # ===========================================================================

  order_via_channel:
    description: >-
      Order -> Channel for demand segmentation.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: orders
      vg:domain_key: id
      vg:range_key: channel_id
      vg:domain_class: Order
      vg:range_class: Channel
      vg:operation_types: '["direct_join"]'
    range: Channel

  order_from_account:
    description: >-
      Order -> RetailAccount for customer identification.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: orders
      vg:domain_key: id
      vg:range_key: retail_account_id
      vg:domain_class: Order
      vg:range_class: RetailAccount
      vg:operation_types: '["direct_join"]'
    range: RetailAccount

  order_to_location:
    description: >-
      Order -> RetailLocation for delivery destination.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: orders
      vg:domain_key: id
      vg:range_key: retail_location_id
      vg:domain_class: Order
      vg:range_class: RetailLocation
      vg:operation_types: '["direct_join"]'
    range: RetailLocation

  order_with_promo:
    description: >-
      Order -> Promotion for promotional orders.
      Pattern 3.7: Temporal relationship based on promo dates.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: orders
      vg:domain_key: id
      vg:range_key: promo_id
      vg:domain_class: Order
      vg:range_class: Promotion
      vg:operation_types: '["direct_join", "temporal_traversal"]'
    range: Promotion

  order_line_sku:
    description: >-
      OrderLine -> SKU for demand to product mapping.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: order_lines
      vg:domain_key: '["order_id", "line_number"]'
      vg:range_key: sku_id
      vg:domain_class: OrderLine
      vg:range_class: SKU
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "quantity_cases", "type": "integer", "unit": "cases"}, {"name": "unit_price", "type": "decimal", "unit": "USD"}]'
    range: SKU

  allocation_from_batch:
    description: >-
      OrderAllocation -> Batch for inventory commitment.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: order_allocations
      vg:domain_key: id
      vg:range_key: batch_id
      vg:domain_class: OrderAllocation
      vg:range_class: Batch
      vg:operation_types: '["direct_join", "recursive_traversal"]'
    range: Batch

  # ===========================================================================
  # FULFILL Domain Relationships
  # ===========================================================================

  dc_in_division:
    description: >-
      DistributionCenter -> Division for regional organization.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: distribution_centers
      vg:domain_key: id
      vg:range_key: division_id
      vg:domain_class: DistributionCenter
      vg:range_class: Division
      vg:operation_types: '["direct_join"]'
    range: Division

  account_in_division:
    description: >-
      RetailAccount -> Division for account hierarchy.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: retail_accounts
      vg:domain_key: id
      vg:range_key: division_id
      vg:domain_class: RetailAccount
      vg:range_class: Division
      vg:operation_types: '["direct_join"]'
    range: Division

  account_via_channel:
    description: >-
      RetailAccount -> Channel for channel segmentation.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: retail_accounts
      vg:domain_key: id
      vg:range_key: channel_id
      vg:domain_class: RetailAccount
      vg:range_class: Channel
      vg:operation_types: '["direct_join"]'
    range: Channel

  location_of_account:
    description: >-
      RetailLocation -> RetailAccount for store hierarchy.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: retail_locations
      vg:domain_key: id
      vg:range_key: retail_account_id
      vg:domain_class: RetailLocation
      vg:range_class: RetailAccount
      vg:operation_types: '["direct_join"]'
    range: RetailAccount

  location_served_by_dc:
    description: >-
      RetailLocation -> DistributionCenter for fulfillment assignment.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: retail_locations
      vg:domain_key: id
      vg:range_key: primary_dc_id
      vg:domain_class: RetailLocation
      vg:range_class: DistributionCenter
      vg:operation_types: '["direct_join", "centrality"]'
      vg:context: >-
        {
          "definition": "Primary DC serving this retail location",
          "llm_prompt_hint": "Use centrality() on DC side to find bottleneck DCs"
        }
    range: DistributionCenter

  location_in_division_shortcut:
    description: >-
      RetailLocation -> Division via flattened view (Pattern 3.2).
      Shortcut edge bypassing account for fast aggregation.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: v_location_divisions
      vg:domain_key: location_id
      vg:range_key: division_id
      vg:domain_class: RetailLocation
      vg:range_class: Division
      vg:operation_types: '["direct_join", "hierarchical_aggregation"]'
      vg:context: >-
        {
          "definition": "Flattened hierarchy for fast division aggregation",
          "llm_prompt_hint": "Use instead of Location->Account->Division for aggregation"
        }
    range: Division

  shipment_line_batch:
    description: >-
      ShipmentLine -> Batch for lot traceability.
      Key edge for forward recall trace.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipment_lines
      vg:domain_key: '["shipment_id", "line_number"]'
      vg:range_key: batch_id
      vg:domain_class: ShipmentLine
      vg:range_class: Batch
      vg:operation_types: '["direct_join", "recursive_traversal"]'
      vg:edge_attributes: '[{"name": "lot_number", "type": "string"}, {"name": "batch_fraction", "type": "decimal"}]'
      vg:context: >-
        {
          "definition": "Batch shipped in this line for traceability",
          "llm_prompt_hint": "Key edge for recall trace: batch -> shipment_lines -> shipments -> destination"
        }
    range: Batch

  shipment_line_sku:
    description: >-
      ShipmentLine -> SKU for product shipped.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipment_lines
      vg:domain_key: '["shipment_id", "line_number"]'
      vg:range_key: sku_id
      vg:domain_class: ShipmentLine
      vg:range_class: SKU
      vg:operation_types: '["direct_join"]'
    range: SKU

  batch_shipped_to_shortcut:
    description: >-
      Batch -> destination via v_batch_destinations (Pattern 3.6).
      Shortcut edge bypassing Shipment node for fast recall trace.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: v_batch_destinations
      vg:domain_key: batch_id
      vg:range_key: destination_id
      vg:domain_class: Batch
      vg:range_class: RetailLocation
      vg:operation_types: '["recursive_traversal"]'
      vg:edge_attributes: '[{"name": "ship_date", "type": "date"}, {"name": "quantity_cases", "type": "integer"}]'
      vg:sql_filter: "destination_type = 'store'"
      vg:context: >-
        {
          "definition": "Direct batch-to-store link for fast recall trace",
          "llm_prompt_hint": "Use for recall when carrier details not needed; 10x faster than via shipments"
        }
    range: RetailLocation

  # ===========================================================================
  # LOGISTICS Domain Relationships
  # ===========================================================================

  shipment_via_carrier:
    description: >-
      Shipment -> Carrier for transport provider.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipments
      vg:domain_key: id
      vg:range_key: carrier_id
      vg:domain_class: Shipment
      vg:range_class: Carrier
      vg:operation_types: '["direct_join"]'
    range: Carrier

  shipment_uses_route:
    description: >-
      Shipment -> Route for transport path.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipments
      vg:domain_key: id
      vg:range_key: route_id
      vg:domain_class: Shipment
      vg:range_class: Route
      vg:operation_types: '["direct_join", "path_aggregation"]'
    range: Route

  contract_with_carrier:
    description: >-
      CarrierContract -> Carrier relationship.
      Pattern 3.7: Temporal bounds for contract effectivity.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: carrier_contracts
      vg:domain_key: id
      vg:range_key: carrier_id
      vg:domain_class: CarrierContract
      vg:range_class: Carrier
      vg:operation_types: '["direct_join", "temporal_traversal"]'
      vg:temporal_bounds: '{"start_col": "effective_from", "end_col": "effective_to"}'
      vg:sql_filter: "status = 'active'"
    range: Carrier

  rate_under_contract:
    description: >-
      CarrierRate -> CarrierContract for rate agreement.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: carrier_rates
      vg:domain_key: id
      vg:range_key: contract_id
      vg:domain_class: CarrierRate
      vg:range_class: CarrierContract
      vg:operation_types: '["direct_join", "temporal_traversal"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "rate_per_kg", "type": "decimal", "unit": "USD/kg"}, {"name": "rate_per_case", "type": "decimal", "unit": "USD/case"}, {"name": "transit_days", "type": "integer", "unit": "days"}]'
    range: CarrierContract

  route_has_segment:
    description: >-
      Route -> RouteSegment via route_segment_assignments.
      Enables multi-leg route composition.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: route_segment_assignments
      vg:domain_key: route_id
      vg:range_key: segment_id
      vg:domain_class: Route
      vg:range_class: RouteSegment
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:edge_attributes: '[{"name": "sequence", "type": "integer"}]'
    range: RouteSegment

  segment_transport:
    description: >-
      RouteSegment with distance and time for shortest_path.
      Uses normalized view for consistent units.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: v_transport_normalized
      vg:domain_key: origin_id
      vg:range_key: destination_id
      vg:domain_class: Port
      vg:range_class: Port
      vg:operation_types: '["shortest_path", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "distance_km", "type": "decimal", "unit": "km"}, {"name": "transit_time_hours", "type": "decimal", "unit": "hours"}]'
      vg:sql_filter: "is_active = true"
      vg:context: >-
        {
          "definition": "Transport segment with normalized distance/time",
          "llm_prompt_hint": "Use shortest_path with distance_km or transit_time_hours as weight"
        }
    range: Port

  leg_on_shipment:
    description: >-
      ShipmentLeg -> Shipment for multi-leg execution tracking.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipment_legs
      vg:domain_key: id
      vg:range_key: shipment_id
      vg:domain_class: ShipmentLeg
      vg:range_class: Shipment
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "freight_cost", "type": "decimal", "unit": "USD"}]'
    range: Shipment

  leg_uses_segment:
    description: >-
      ShipmentLeg -> RouteSegment for actual transport path.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipment_legs
      vg:domain_key: id
      vg:range_key: segment_id
      vg:domain_class: ShipmentLeg
      vg:range_class: RouteSegment
      vg:operation_types: '["direct_join"]'
    range: RouteSegment

  # ===========================================================================
  # ESG Domain Relationships
  # ===========================================================================

  emission_for_shipment:
    description: >-
      ShipmentEmission -> Shipment for carbon tracking.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipment_emissions
      vg:domain_key: id
      vg:range_key: shipment_id
      vg:domain_class: ShipmentEmission
      vg:range_class: Shipment
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "co2_kg", "type": "decimal", "unit": "kg CO2"}]'
    range: Shipment

  supplier_esg:
    description: >-
      Supplier -> SupplierESGScore for sustainability assessment.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: supplier_esg_scores
      vg:domain_key: supplier_id
      vg:range_key: id
      vg:domain_class: Supplier
      vg:range_class: SupplierESGScore
      vg:operation_types: '["direct_join"]'
    range: SupplierESGScore

  modal_shift_for_segment:
    description: >-
      ModalShiftOpportunity -> RouteSegment for carbon reduction opportunities.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: modal_shift_opportunities
      vg:domain_key: id
      vg:range_key: route_segment_id
      vg:domain_class: ModalShiftOpportunity
      vg:range_class: RouteSegment
      vg:operation_types: '["direct_join"]'
    range: RouteSegment

  # ===========================================================================
  # PLAN Domain Relationships
  # ===========================================================================

  pos_at_location:
    description: >-
      POSSale -> RetailLocation for demand source.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: pos_sales
      vg:domain_key: id
      vg:range_key: retail_location_id
      vg:domain_class: POSSale
      vg:range_class: RetailLocation
      vg:operation_types: '["direct_join"]'
    range: RetailLocation

  pos_for_sku:
    description: >-
      POSSale -> SKU for demand by product.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: pos_sales
      vg:domain_key: id
      vg:range_key: sku_id
      vg:domain_class: POSSale
      vg:range_class: SKU
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "quantity_eaches", "type": "integer", "unit": "eaches"}]'
    range: SKU

  forecast_for_sku:
    description: >-
      DemandForecast -> SKU for demand prediction.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: demand_forecasts
      vg:domain_key: id
      vg:range_key: sku_id
      vg:domain_class: DemandForecast
      vg:range_class: SKU
      vg:operation_types: '["direct_join", "path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "forecast_quantity_cases", "type": "decimal", "unit": "cases"}]'
    range: SKU

  supply_plan_for_sku:
    description: >-
      SupplyPlan -> SKU for supply commitment.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: supply_plans
      vg:domain_key: id
      vg:range_key: sku_id
      vg:domain_class: SupplyPlan
      vg:range_class: SKU
      vg:operation_types: '["direct_join", "path_aggregation"]'
    range: SKU

  capacity_at_plant:
    description: >-
      CapacityPlan -> Plant for capacity availability.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: capacity_plans
      vg:domain_key: id
      vg:range_key: plant_id
      vg:domain_class: CapacityPlan
      vg:range_class: Plant
      vg:operation_types: '["direct_join"]'
    range: Plant

  # ===========================================================================
  # RETURN Domain Relationships
  # ===========================================================================

  return_to_dc:
    description: >-
      Return -> DistributionCenter for return destination.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: returns
      vg:domain_key: id
      vg:range_key: dc_id
      vg:domain_class: Return
      vg:range_class: DistributionCenter
      vg:operation_types: '["direct_join"]'
    range: DistributionCenter

  return_from_location:
    description: >-
      Return -> RetailLocation for return source.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: returns
      vg:domain_key: id
      vg:range_key: retail_location_id
      vg:domain_class: Return
      vg:range_class: RetailLocation
      vg:operation_types: '["direct_join"]'
    range: RetailLocation

  return_line_batch:
    description: >-
      ReturnLine -> Batch for lot tracking on returns.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: return_lines
      vg:domain_key: '["return_id", "line_number"]'
      vg:range_key: batch_id
      vg:domain_class: ReturnLine
      vg:range_class: Batch
      vg:operation_types: '["direct_join", "recursive_traversal"]'
    range: Batch

  disposition_from_return:
    description: >-
      DispositionLog -> Return for disposition tracking.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: disposition_logs
      vg:domain_key: id
      vg:range_key: return_id
      vg:domain_class: DispositionLog
      vg:range_class: Return
      vg:operation_types: '["direct_join"]'
    range: Return

  # ===========================================================================
  # ORCHESTRATE Domain Relationships
  # ===========================================================================

  kpi_actual_threshold:
    description: >-
      KPIActual -> KPIThreshold for performance measurement.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: kpi_actuals
      vg:domain_key: id
      vg:range_key: kpi_id
      vg:domain_class: KPIActual
      vg:range_class: KPIThreshold
      vg:operation_types: '["direct_join"]'
    range: KPIThreshold

  osa_at_location:
    description: >-
      OSAMetric -> RetailLocation for OSA measurement.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: osa_metrics
      vg:domain_key: id
      vg:range_key: retail_location_id
      vg:domain_class: OSAMetric
      vg:range_class: RetailLocation
      vg:operation_types: '["direct_join", "centrality"]'
      vg:context: >-
        {
          "definition": "OSA measurement at specific location",
          "llm_prompt_hint": "Correlate with location_served_by_dc to find DC bottlenecks"
        }
    range: RetailLocation

  osa_for_sku:
    description: >-
      OSAMetric -> SKU for product availability tracking.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: osa_metrics
      vg:domain_key: id
      vg:range_key: sku_id
      vg:domain_class: OSAMetric
      vg:range_class: SKU
      vg:operation_types: '["direct_join"]'
    range: SKU

  # ===========================================================================
  # BEAST MODE Cross-Domain Relationships
  # ===========================================================================

  recall_trace_path:
    description: >-
      Composite path for recall tracing: Batch -> ShipmentLines -> Shipments -> Destinations.
      Target: <5 seconds for 1 batch -> 47,500 affected orders.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: v_batch_destinations
      vg:domain_key: batch_id
      vg:range_key: destination_id
      vg:domain_class: Batch
      vg:range_class: RetailLocation
      vg:operation_types: '["recursive_traversal"]'
      vg:context: >-
        {
          "definition": "Beast mode recall trace path",
          "llm_prompt_hint": "Use traverse() handler for horizontal fan-out from contaminated batch",
          "examples": ["Trace B-2024-RECALL-001 to all affected stores"]
        }
    range: RetailLocation

  landed_cost_path:
    description: >-
      Aggregate costs along Plant -> DC -> Store path.
      Combines batch cost, freight cost, handling cost.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: shipment_legs
      vg:domain_key: shipment_id
      vg:range_key: segment_id
      vg:domain_class: Shipment
      vg:range_class: RouteSegment
      vg:operation_types: '["path_aggregation"]'
      vg:is_weighted: true
      vg:weight_columns: '[{"name": "freight_cost", "type": "decimal", "unit": "USD"}]'
      vg:context: >-
        {
          "definition": "Cost aggregation along multi-leg shipment path",
          "llm_prompt_hint": "Use path_aggregate() to sum costs across all legs"
        }
    range: RouteSegment

  spof_detection:
    description: >-
      Single-source ingredient detection via v_single_source_ingredients view.
    is_a: slot
    instantiates:
      - vg:SQLMappedRelationship
    annotations:
      vg:edge_table: v_single_source_ingredients
      vg:domain_key: ingredient_id
      vg:range_key: ingredient_id
      vg:domain_class: Ingredient
      vg:range_class: Ingredient
      vg:operation_types: '["resilience_analysis"]'
      vg:context: >-
        {
          "definition": "Single-source (SPOF) ingredient identification",
          "llm_prompt_hint": "Direct query on view; no handler needed for basic detection"
        }
    range: Ingredient
