# Virtual Graph Ontology Template (LinkML Format)
#
# This template defines the structure for Virtual Graph ontologies using
# LinkML-compliant schema with VG extensions.
#
# References:
# - LinkML: https://linkml.io/
# - OWL 2: https://www.w3.org/TR/owl-ref/
# - Virtual Graph Metamodel: ontology/virt_graph.yaml
#
# Usage:
# 1. Copy this template to create a new ontology (e.g., my_domain.yaml)
# 2. Fill in the schema metadata (id, name, description)
# 3. Define entity classes with vg:SQLMappedClass instantiation
# 4. Define relationship classes with vg:SQLMappedRelationship instantiation
# 5. Validate:
#    - Structure: poetry run linkml-lint --validate-only ontology/my_domain.yaml
#    - VG annotations: OntologyAccessor("ontology/my_domain.yaml", validate=True)

# =============================================================================
# SCHEMA METADATA
# =============================================================================
id: https://virt-graph.dev/schemas/<domain_name>
name: <domain_name>
version: "1.0"
description: >-
  <Description of this domain ontology>

prefixes:
  linkml: https://w3id.org/linkml/
  vg: https://virt-graph.dev/
  # Add your own prefix:
  # myns: https://virt-graph.dev/schemas/<domain_name>/

imports:
  - linkml:types

default_range: string

# =============================================================================
# SCHEMA-LEVEL ANNOTATIONS (Database Connection)
# =============================================================================
annotations:
  vg:database_type: postgresql
  vg:database_version: "14"
  vg:connection_string: "postgresql://user:pass@host:port/database"

# =============================================================================
# ENUMS (Optional)
# =============================================================================
# Define enums for constrained value sets
#
# enums:
#   MyEnum:
#     description: "Description of this enum"
#     permissible_values:
#       VALUE_1:
#         description: "First value"
#       VALUE_2:
#         description: "Second value"

# =============================================================================
# CLASSES
# =============================================================================
classes:

  # ===========================================================================
  # ENTITY CLASSES (TBox) - Map to database tables
  # ===========================================================================
  #
  # Entity classes represent database tables containing domain entities.
  # They MUST instantiate vg:SQLMappedClass and include required annotations.
  #
  # Required annotations:
  #   - vg:table         - SQL table name
  #   - vg:primary_key   - Primary key column
  #
  # Optional annotations:
  #   - vg:identifier    - Natural key column(s) as JSON array: "[col1, col2]"
  #   - vg:soft_delete_column - Soft delete timestamp column
  #   - vg:row_count     - Estimated row count for query planning
  #
  # Example:
  #
  # EntityName:
  #   description: "Human-readable description of this entity"
  #   instantiates:
  #     - vg:SQLMappedClass
  #   annotations:
  #     vg:table: table_name
  #     vg:primary_key: id
  #     vg:identifier: "[natural_key_col]"
  #     vg:soft_delete_column: deleted_at
  #     vg:row_count: 1000
  #   attributes:
  #     natural_key_col:
  #       range: string
  #       required: true
  #       description: "Unique identifier"
  #     name:
  #       range: string
  #       required: true
  #       description: "Entity name"
  #     status:
  #       range: MyEnum
  #       description: "Current status"
  #     created_at:
  #       range: datetime
  #       description: "Creation timestamp"

  # --- Define your entity classes below ---


  # ===========================================================================
  # RELATIONSHIP CLASSES (RBox) - Map to foreign key relationships
  # ===========================================================================
  #
  # Relationship classes represent connections between entities.
  # They MUST instantiate vg:SQLMappedRelationship and include required annotations.
  #
  # Required annotations:
  #   - vg:edge_table           - Junction/edge table name (or target table for embedded FKs)
  #   - vg:domain_key           - FK column pointing to domain class
  #   - vg:range_key            - FK column pointing to range class (or 'id' for embedded FKs)
  #   - vg:domain_class         - Name of the domain class
  #   - vg:range_class          - Name of the range class
  #   - vg:traversal_complexity - GREEN, YELLOW, or RED
  #
  # Optional annotations:
  #   # OWL 2 Role Axioms
  #   - vg:transitive           - R(x,y) and R(y,z) implies R(x,z)
  #   - vg:symmetric            - R(x,y) implies R(y,x)
  #   - vg:asymmetric           - R(x,y) implies NOT R(y,x)
  #   - vg:reflexive            - R(x,x) always holds
  #   - vg:irreflexive          - R(x,x) never holds (no self-loops)
  #   - vg:functional           - At most one range per domain
  #   - vg:inverse_functional   - At most one domain per range
  #
  #   # Virtual Graph Extensions
  #   - vg:acyclic              - DAG constraint (no cycles)
  #   - vg:is_hierarchical      - Has tier/level structure
  #   - vg:is_weighted          - Has numeric edge weights
  #   - vg:inverse_of           - Name of inverse relationship
  #
  #   # Cardinality
  #   - vg:cardinality_domain   - e.g., "0..*", "1..1"
  #   - vg:cardinality_range    - e.g., "0..*", "0..1"
  #
  #   # DDL Metadata
  #   - vg:has_self_ref_constraint - CHECK constraint prevents self-loops
  #   - vg:has_unique_edge_index   - UNIQUE index prevents duplicate edges
  #   - vg:indexed_columns         - JSON array of indexed columns
  #
  #   # Weight Columns (for RED complexity)
  #   - vg:weight_columns      - JSON array: '[{"name": "col", "type": "decimal"}]'
  #
  #   # Statistics
  #   - vg:row_count           - Estimated edge count
  #
  # Traversal Complexity Guide:
  #   GREEN  - Simple FK join, no recursion needed (direct SQL)
  #   YELLOW - Recursive traversal needed (frontier-batched BFS)
  #   RED    - Network algorithm needed (loads subgraph into NetworkX)
  #
  # Example (GREEN - Simple FK):
  #
  # BelongsTo:
  #   description: "Entity belongs to a category"
  #   instantiates:
  #     - vg:SQLMappedRelationship
  #   annotations:
  #     vg:edge_table: entities
  #     vg:domain_key: category_id
  #     vg:range_key: id
  #     vg:domain_class: Entity
  #     vg:range_class: Category
  #     vg:traversal_complexity: GREEN
  #     vg:functional: true
  #     vg:cardinality_domain: "1..1"
  #     vg:cardinality_range: "0..*"
  #
  # Example (YELLOW - Recursive traversal):
  #
  # ChildOf:
  #   description: "Entity is a child of another entity (hierarchy)"
  #   instantiates:
  #     - vg:SQLMappedRelationship
  #   annotations:
  #     vg:edge_table: entity_hierarchy
  #     vg:domain_key: child_id
  #     vg:range_key: parent_id
  #     vg:domain_class: Entity
  #     vg:range_class: Entity
  #     vg:traversal_complexity: YELLOW
  #     vg:asymmetric: true
  #     vg:irreflexive: true
  #     vg:acyclic: true
  #     vg:inverse_of: ParentOf
  #     vg:cardinality_domain: "0..*"
  #     vg:cardinality_range: "0..*"
  #     vg:has_self_ref_constraint: true
  #     vg:has_unique_edge_index: true
  #     vg:row_count: 5000
  #   attributes:
  #     weight:
  #       range: decimal
  #       description: "Edge weight"
  #
  # Example (RED - Network algorithm):
  #
  # ConnectedTo:
  #   description: "Weighted connection between nodes"
  #   instantiates:
  #     - vg:SQLMappedRelationship
  #   annotations:
  #     vg:edge_table: connections
  #     vg:domain_key: source_id
  #     vg:range_key: target_id
  #     vg:domain_class: Node
  #     vg:range_class: Node
  #     vg:traversal_complexity: RED
  #     vg:is_weighted: true
  #     vg:weight_columns: '[{"name": "distance", "type": "decimal"}, {"name": "cost", "type": "decimal"}]'
  #     vg:cardinality_domain: "0..*"
  #     vg:cardinality_range: "0..*"
  #     vg:row_count: 1000
  #   attributes:
  #     distance:
  #       range: decimal
  #       description: "Distance in km"
  #     cost:
  #       range: decimal
  #       description: "Cost in USD"

  # --- Define your relationship classes below ---


# =============================================================================
# VALIDATION REFERENCE
# =============================================================================
#
# Two-layer validation is required:
#
# 1. LinkML Schema Validation (structure):
#    poetry run linkml-lint --validate-only ontology/my_domain.yaml
#    - Validates YAML syntax
#    - Validates LinkML schema structure
#    - Does NOT validate VG-specific annotations
#
# 2. VG Annotation Validation (semantics):
#    from virt_graph.ontology import OntologyAccessor
#    ontology = OntologyAccessor("ontology/my_domain.yaml")  # Raises if invalid
#    - Validates required VG annotations are present
#    - Validates traversal_complexity values
#    - Validates domain_class/range_class references
#
# =============================================================================
# CARDINALITY NOTATION REFERENCE
# =============================================================================
#
# | Notation | Meaning                           |
# |----------|-----------------------------------|
# | "1..1"   | Exactly one (required)            |
# | "0..1"   | Zero or one (optional)            |
# | "1..*"   | One or more                       |
# | "0..*"   | Zero or more                      |
#
# =============================================================================
# TRAVERSAL COMPLEXITY REFERENCE
# =============================================================================
#
# | Complexity | Description                    | Handler Required |
# |------------|--------------------------------|------------------|
# | GREEN      | Simple FK join, no recursion   | No (direct SQL)  |
# | YELLOW     | Recursive traversal needed     | Yes (traverse)   |
# | RED        | Network algorithm needed       | Yes (NetworkX)   |
